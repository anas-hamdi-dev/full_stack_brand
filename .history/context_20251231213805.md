# Backend Context Documentation

This document describes the backend requirements derived from the frontend codebase. It serves as a specification for implementing the backend API and database schema.

## Table of Contents

1. [Entity Definitions](#entity-definitions)
2. [Relationships](#relationships)
3. [User Roles & Permissions](#user-roles--permissions)
4. [API Responsibilities](#api-responsibilities)
5. [Data Constraints & Assumptions](#data-constraints--assumptions)

---

## Entity Definitions

### Users Table

**Table Name:** `users`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique user identifier |
| `email` | string | UNIQUE, NOT NULL | User email address (used for login) |
| `password` | string | NOT NULL | Hashed password (never return in API responses) |
| `full_name` | string | NOT NULL | User's full name |
| `first_name` | string | NULLABLE | User's first name (optional) |
| `last_name` | string | NULLABLE | User's last name (optional) |
| `phone` | string | NULLABLE | User's phone number (format: "+216 XX XXX XXX") |
| `role` | enum | NOT NULL | User role: `"client"` or `"brand_owner"` |
| `avatar_url` | string (URL) | NULLABLE | URL to user's avatar image |
| `brand_id` | string (UUID) | NULLABLE, FOREIGN KEY → brands.id | For brand owners: link to their brand |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | timestamp | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes:**
- `brand_id` is only populated for users with `role = "brand_owner"`
- `brand_id` should be NULL for users with `role = "client"`
- Password must be hashed using secure hashing algorithm (e.g., bcrypt)

---

### Categories Table

**Table Name:** `categories`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique category identifier |
| `name` | string | UNIQUE, NOT NULL | Category name (e.g., "Fashion", "Footwear") |
| `icon` | string | NOT NULL | Icon identifier/name (e.g., "Shirt", "Footprints") |
| `description` | text | NULLABLE | Category description |
| `brand_count` | integer | NULLABLE | Cached count of brands in this category (computed) |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Category creation timestamp |

**Notes:**
- Categories are pre-defined and typically not created by users
- `brand_count` should be updated when brands are added/removed from category
- Icon field stores icon identifier (frontend maps to actual icon component)

---

### Brands Table

**Table Name:** `brands`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique brand identifier |
| `name` | string | NOT NULL | Brand name |
| `category_id` | string (UUID) | NULLABLE, FOREIGN KEY → categories.id | Brand category |
| `description` | text | NULLABLE | Brand description |
| `logo_url` | string (URL) | NULLABLE | URL to brand logo image |
| `location` | string | NULLABLE | Brand location (e.g., "Tunis, Tunisia") |
| `website` | string (URL) | NULLABLE | Brand website URL |
| `instagram` | string (URL) | NULLABLE | Instagram profile URL |
| `facebook` | string (URL) | NULLABLE | Facebook page URL |
| `phone` | string | NULLABLE | Brand contact phone |
| `email` | string | NULLABLE | Brand contact email |
| `is_featured` | boolean | NULLABLE, DEFAULT false | Whether brand is featured on homepage |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Brand creation timestamp |
| `updated_at` | timestamp | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes:**
- `is_featured` is used to filter featured brands for homepage display
- Social media URLs should be validated as proper URLs
- Brand name should be unique or have uniqueness constraint

---

### Products Table

**Table Name:** `products`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique product identifier |
| `name` | string | NOT NULL | Product name |
| `description` | text | NULLABLE | Product description |
| `brand_id` | string (UUID) | NULLABLE, FOREIGN KEY → brands.id | Brand that owns this product |
| `price` | decimal(10,2) | NULLABLE | Product price (can be null for display-only products) |
| `images` | array of strings (URLs) | NOT NULL, MIN 1 | Array of product image URLs (at least one required) |
| `external_url` | string (URL) | NULLABLE | External link to product page (e.g., brand's website) |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Product creation timestamp |

**Notes:**
- `images` is stored as JSON array or separate `product_images` table (recommend separate table for normalization)
- Products must have at least one image
- `price` can be null (some products may not have pricing)
- Products are owned by brands (brand owners can CRUD their own products)

**Alternative Schema (Normalized):**

If using normalized schema, create separate `product_images` table:

**Table Name:** `product_images`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique image identifier |
| `product_id` | string (UUID) | NOT NULL, FOREIGN KEY → products.id | Product this image belongs to |
| `image_url` | string (URL) | NOT NULL | Image URL |
| `order` | integer | NOT NULL, DEFAULT 0 | Display order (for carousel) |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Image creation timestamp |

---

### Brand Submissions Table

**Table Name:** `brand_submissions`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique submission identifier |
| `brand_name` | string | NOT NULL | Proposed brand name |
| `category` | string | NOT NULL | Category name (string, not FK - may not exist yet) |
| `description` | text | NULLABLE | Brand description |
| `contact_email` | string | NOT NULL | Contact email for submission |
| `contact_phone` | string | NULLABLE | Contact phone |
| `website` | string (URL) | NULLABLE | Brand website |
| `instagram` | string | NULLABLE | Instagram handle/URL |
| `status` | enum | NOT NULL, DEFAULT 'pending' | Status: `"pending"`, `"approved"`, `"rejected"` |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Submission timestamp |

**Notes:**
- This is a submission queue for new brands (not yet approved/created)
- `status` tracks approval workflow
- When approved, a new brand should be created in `brands` table
- `category` is stored as string (may reference non-existent category during submission)

---

### Contact Messages Table

**Table Name:** `contact_messages`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique message identifier |
| `name` | string | NOT NULL | Sender's name |
| `email` | string | NOT NULL | Sender's email |
| `subject` | string | NOT NULL | Message subject |
| `message` | text | NOT NULL | Message content |
| `status` | enum | NOT NULL, DEFAULT 'new' | Status: `"new"`, `"read"`, `"replied"` |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Message timestamp |

**Notes:**
- Used for contact form submissions
- `status` tracks message handling workflow
- No user authentication required (public form)

---

### Favorites Table

**Table Name:** `favorites`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | string (UUID) | PRIMARY KEY, NOT NULL | Unique favorite identifier |
| `user_id` | string (UUID) | NOT NULL, FOREIGN KEY → users.id | User who favorited the product |
| `product_id` | string (UUID) | NOT NULL, FOREIGN KEY → products.id | Product being favorited |
| `created_at` | timestamp | NOT NULL, DEFAULT NOW() | Favorite creation timestamp |

**Notes:**
- Only clients can have favorites (enforced by application logic)
- Composite unique constraint on `(user_id, product_id)` to prevent duplicates
- Used to track which products clients have favorited

---

## Relationships

### Entity Relationship Diagram

```
users
├── brand_id → brands.id (one-to-one, optional, for brand_owner role)
└── favorites (one-to-many)

brands
├── category_id → categories.id (many-to-one)
└── products (one-to-many)

categories
└── brands (one-to-many)

products
├── brand_id → brands.id (many-to-one)
└── favorites (one-to-many)

favorites
├── user_id → users.id (many-to-one)
└── product_id → products.id (many-to-one)

brand_submissions (standalone, no relationships)
contact_messages (standalone, no relationships)
```

### Relationship Details

1. **User → Brand (One-to-One, Optional)**
   - Only exists when `user.role = "brand_owner"`
   - One user can own one brand
   - One brand is owned by one user

2. **Brand → Category (Many-to-One)**
   - Many brands belong to one category
   - Brand can have null category_id

3. **Brand → Products (One-to-Many)**
   - One brand can have many products
   - Products must belong to a brand

4. **User → Favorites (One-to-Many)**
   - One user can favorite many products
   - Only clients can create favorites

5. **Product → Favorites (One-to-Many)**
   - One product can be favorited by many users

---

## User Roles & Permissions

### Role: `client`

**Capabilities:**
- View all brands and products (public data)
- Browse brands by category
- View brand details and product details
- Add/remove products to favorites
- View own favorites list
- Submit brand submission requests (public form)
- Submit contact messages (public form)
- Update own profile (name, email, phone, avatar)

**Restrictions:**
- Cannot create/edit/delete brands
- Cannot create/edit/delete products
- Cannot access brand owner dashboard
- Cannot modify other users' data

### Role: `brand_owner`

**Capabilities:**
- All client capabilities (can browse and favorite)
- Access brand owner dashboard
- View and edit own brand information:
  - Brand name, description, category
  - Logo, location, contact info
  - Website, social media links
- Full CRUD on own products:
  - Create products with multiple images
  - Update product details
  - Delete products
- View products belonging to own brand
- Update own profile (name, email, phone, avatar)

**Restrictions:**
- Can only edit products belonging to their brand (`brand_id` matches `user.brand_id`)
- Cannot edit other brands
- Cannot edit products from other brands
- Cannot access other brand owners' dashboards

### Authentication & Authorization

**Authentication:**
- Email + password login
- Session-based authentication (JWT tokens recommended)
- Sign-up creates new user account
- Sign-out invalidates session

**Authorization Checks:**
- Brand owner operations must verify `user.brand_id` matches resource ownership
- Favorites operations must verify `user.role = "client"`
- Profile updates must verify user owns the profile being updated

---

## API Responsibilities

### Authentication Endpoints

#### `POST /api/auth/signin`
- **Request:** `{ email: string, password: string }`
- **Response:** `{ user: User, session: Session }`
- **Errors:** Invalid credentials (401)

#### `POST /api/auth/signup`
- **Request:** `{ email: string, password: string, firstName: string, lastName: string, phone?: string, role: "client" | "brand_owner", brandData?: {...} }`
- **Response:** `{ user: User, session: Session }`
- **Behavior:** 
  - If `role = "brand_owner"`, create brand with minimal data
  - Auto-login user after signup
- **Errors:** Email already exists (409)

#### `POST /api/auth/signout`
- **Request:** (authenticated)
- **Response:** `{ success: boolean }`
- **Behavior:** Invalidate session

#### `GET /api/auth/me`
- **Request:** (authenticated)
- **Response:** `{ user: User }`
- **Behavior:** Return current authenticated user

---

### Users Endpoints

#### `GET /api/users/:id`
- **Request:** (authenticated)
- **Response:** `User` (without password)
- **Authorization:** User can only view own profile

#### `PATCH /api/users/:id`
- **Request:** `{ full_name?: string, email?: string, phone?: string, avatar_url?: string }`
- **Response:** `User` (updated, without password)
- **Authorization:** User can only update own profile
- **Validation:** Email uniqueness if changed

---

### Categories Endpoints

#### `GET /api/categories`
- **Request:** (public)
- **Response:** `Category[]`
- **Behavior:** Return all categories, sorted by name

#### `GET /api/categories/:id`
- **Request:** (public)
- **Response:** `Category`
- **Behavior:** Return single category with brand_count

---

### Brands Endpoints

#### `GET /api/brands`
- **Request:** (public, optional query params: `category_id`, `featured`, `search`)
- **Response:** `Brand[]`
- **Behavior:** 
  - Filter by category if `category_id` provided
  - Filter featured brands if `featured=true`
  - Search by name if `search` provided
  - Sort by `created_at` DESC by default

#### `GET /api/brands/:id`
- **Request:** (public)
- **Response:** `Brand` (with nested category info)
- **Behavior:** Return brand with category relationship

#### `GET /api/brands/featured`
- **Request:** (public)
- **Response:** `Brand[]`
- **Behavior:** Return only brands where `is_featured = true`

#### `PATCH /api/brands/:id`
- **Request:** `{ name?, category_id?, description?, logo_url?, location?, website?, instagram?, facebook?, phone?, email? }`
- **Response:** `Brand` (updated)
- **Authorization:** Only brand owner who owns this brand (`user.brand_id = brand.id`)
- **Validation:** 
  - Brand name required
  - Category must exist if provided
  - URLs must be valid

---

### Products Endpoints

#### `GET /api/products`
- **Request:** (public, optional query params: `brand_id`, `category_id`, `search`)
- **Response:** `Product[]` (with nested brand info)
- **Behavior:** 
  - Filter by brand if `brand_id` provided
  - Filter by category via brand if `category_id` provided
  - Search by name if `search` provided
  - Include brand relationship data

#### `GET /api/products/:id`
- **Request:** (public)
- **Response:** `Product` (with nested brand info)
- **Behavior:** Return product with brand relationship

#### `GET /api/brands/:brandId/products`
- **Request:** (public)
- **Response:** `Product[]`
- **Behavior:** Return all products for a specific brand

#### `POST /api/products`
- **Request:** `{ name: string, description?: string, brand_id: string, price?: number, images: string[], external_url?: string }`
- **Response:** `Product` (created, with nested brand info)
- **Authorization:** Only brand owner who owns the brand (`user.brand_id = brand_id`)
- **Validation:**
  - Name required (min 2 characters)
  - At least one image required
  - Images must be valid URLs
  - Price must be non-negative if provided
  - Brand must exist

#### `PATCH /api/products/:id`
- **Request:** `{ name?, description?, price?, images?, external_url? }`
- **Response:** `Product` (updated, with nested brand info)
- **Authorization:** Only brand owner who owns the product's brand
- **Validation:** Same as POST

#### `DELETE /api/products/:id`
- **Request:** (authenticated)
- **Response:** `{ success: boolean }`
- **Authorization:** Only brand owner who owns the product's brand
- **Behavior:** Soft delete or hard delete (frontend expects hard delete)

---

### Favorites Endpoints

#### `GET /api/favorites`
- **Request:** (authenticated, client role only)
- **Response:** `Product[]` (user's favorited products with brand info)
- **Authorization:** Must be client role
- **Behavior:** Return all products favorited by current user

#### `POST /api/favorites`
- **Request:** `{ product_id: string }`
- **Response:** `Favorite` (created)
- **Authorization:** Must be client role
- **Validation:** Product must exist
- **Behavior:** Create favorite if doesn't exist (idempotent)

#### `DELETE /api/favorites/:productId`
- **Request:** (authenticated, client role only)
- **Response:** `{ success: boolean }`
- **Authorization:** Must be client role, must own the favorite
- **Behavior:** Remove favorite

#### `GET /api/favorites/check/:productId`
- **Request:** (authenticated, client role only)
- **Response:** `{ isFavorite: boolean }`
- **Authorization:** Must be client role
- **Behavior:** Check if product is favorited by current user

---

### Brand Submissions Endpoints

#### `POST /api/brand-submissions`
- **Request:** `{ brand_name: string, category: string, description?: string, contact_email: string, contact_phone?: string, website?: string, instagram?: string }`
- **Response:** `BrandSubmission` (created)
- **Authorization:** Public (no auth required)
- **Validation:**
  - Brand name required
  - Category required
  - Contact email required and valid
- **Behavior:** Create submission with status "pending"

---

### Contact Messages Endpoints

#### `POST /api/contact-messages`
- **Request:** `{ name: string, email: string, subject: string, message: string }`
- **Response:** `ContactMessage` (created)
- **Authorization:** Public (no auth required)
- **Validation:**
  - All fields required
  - Email must be valid
- **Behavior:** Create message with status "new"

---

## Data Constraints & Assumptions

### General Constraints

1. **IDs:** All IDs are UUIDs (string format)
2. **Timestamps:** All timestamps are ISO 8601 strings (e.g., "2024-01-15T10:00:00Z")
3. **URLs:** All URL fields should be validated as proper URLs
4. **Email:** Email fields must be validated as proper email addresses
5. **Phone:** Phone numbers stored as strings (format: "+216 XX XXX XXX" for Tunisia)

### User Constraints

1. **Email Uniqueness:** Email must be unique across all users
2. **Role Immutability:** User role should not change after creation (or require special admin action)
3. **Brand Owner Brand:** Brand owners must have a `brand_id` set (enforced on signup)
4. **Client Brand:** Clients must have `brand_id = NULL`

### Brand Constraints

1. **Brand Name:** Should be unique or have uniqueness constraint
2. **Category:** `category_id` can be null (brands without category)
3. **Featured:** `is_featured` defaults to `false`
4. **Ownership:** One brand can only be owned by one user

### Product Constraints

1. **Images:** Products must have at least one image
2. **Brand Required:** Products must belong to a brand (`brand_id` required)
3. **Price:** Price can be null (for display-only products)
4. **Image URLs:** All image URLs must be valid URLs

### Category Constraints

1. **Name Uniqueness:** Category names must be unique
2. **Brand Count:** `brand_count` should be computed/updated when brands change categories

### Favorite Constraints

1. **Client Only:** Only users with `role = "client"` can create favorites
2. **Uniqueness:** One user cannot favorite the same product twice (composite unique constraint)
3. **Product Existence:** Product must exist when creating favorite

### Brand Submission Constraints

1. **Status:** Status defaults to "pending"
2. **Category:** Category stored as string (may not exist in categories table yet)

### Contact Message Constraints

1. **Status:** Status defaults to "new"
2. **Public Access:** No authentication required

### Data Relationships

1. **Cascading Deletes:** 
   - Deleting a brand should delete all associated products (or prevent deletion if products exist)
   - Deleting a product should delete all associated favorites
   - Deleting a user should handle favorites (delete or orphan)

2. **Referential Integrity:**
   - All foreign keys must reference existing records
   - Foreign key constraints should be enforced at database level

### API Response Format

**Success Response:**
```json
{
  "data": { ... },
  "message": "Success message (optional)"
}
```

**Error Response:**
```json
{
  "error": {
    "message": "Error message",
    "code": "ERROR_CODE",
    "details": { ... } // Optional
  }
}
```

**HTTP Status Codes:**
- `200` - Success
- `201` - Created
- `400` - Bad Request (validation errors)
- `401` - Unauthorized (not authenticated)
- `403` - Forbidden (not authorized)
- `404` - Not Found
- `409` - Conflict (e.g., email already exists)
- `500` - Internal Server Error

### Pagination

For list endpoints (`GET /api/brands`, `GET /api/products`), consider pagination:

**Query Parameters:**
- `page` - Page number (default: 1)
- `limit` - Items per page (default: 20, max: 100)

**Response Format:**
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "totalPages": 5
  }
}
```

### Sorting

List endpoints should support sorting:

**Query Parameters:**
- `sortBy` - Field to sort by (e.g., "created_at", "name")
- `sortOrder` - "asc" or "desc" (default: "desc" for dates, "asc" for names)

### Filtering

List endpoints should support filtering:

**Query Parameters:**
- `category_id` - Filter by category
- `brand_id` - Filter by brand
- `featured` - Filter featured items (boolean)
- `search` - Search by name/description

---

## Additional Notes

### Frontend Expectations

1. **Nested Relationships:** Frontend expects nested data (e.g., products include brand info, brands include category info)
2. **Real-time Updates:** Frontend may need to refresh data after mutations (consider WebSocket or polling)
3. **Image Storage:** Image URLs are expected to be publicly accessible URLs (consider CDN or object storage)
4. **Form Validation:** Frontend performs client-side validation; backend should also validate
5. **Error Messages:** Error messages should be user-friendly and in the same language as frontend

### Security Considerations

1. **Password Hashing:** Use secure hashing (bcrypt, Argon2)
2. **JWT Tokens:** Use JWT for session management with expiration
3. **CORS:** Configure CORS for frontend domain
4. **Rate Limiting:** Implement rate limiting on auth endpoints
5. **Input Sanitization:** Sanitize all user inputs
6. **SQL Injection:** Use parameterized queries
7. **XSS Prevention:** Validate and sanitize URLs and text content

### Performance Considerations

1. **Database Indexes:** 
   - Index on `users.email`
   - Index on `brands.category_id`
   - Index on `products.brand_id`
   - Composite index on `favorites(user_id, product_id)`
2. **Caching:** Consider caching categories and featured brands
3. **Image Optimization:** Serve optimized images via CDN
4. **Query Optimization:** Use eager loading for nested relationships

---

## Summary

This backend must support:

- **Two user roles:** clients and brand owners
- **Core entities:** users, brands, products, categories, favorites, brand submissions, contact messages
- **CRUD operations:** Full CRUD for brands and products (with ownership checks)
- **Authentication:** Email/password with session management
- **Authorization:** Role-based and resource ownership checks
- **Public endpoints:** Categories, brands, products (read-only)
- **Protected endpoints:** User profile, favorites, brand/product management

The backend should align with the frontend's data structures and user flows as defined in `src/data/staticData.ts` and the frontend components.
